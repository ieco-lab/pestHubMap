---
title: "State Shapefiles"
output: html_document
---

This is an R markdown file for retrieving shapefiles from State or Counties

```{r packages, include = FALSE, messages = FALSE, warning = FALSE}
library(tidyverse) #for wrangling
library(here) #relative working directory
library(tigris) #geopolitical boundary spatial files
library(sf) #spatial harmonization
library(raster) #to deal with rasters
library(terra) #dealing with rasters and shps at the same time
library(exactextractr) #for extracting ensemble values to subcounties

#In case here sets to the wrong directory unload the package using this code and then reload above
#detach("package:here", unload = TRUE)

#rm(list = ls()) #removes objects from environment
```

```{r loading pathways and variables, messages = F, warning = F}
import_path <- here("import")
export_path <- here("export")
state_name <- "Pennsylvania"
state_abbr <- "PA" 

```


##Making 1km grid
``` {r 1km grids, messages = F, warning = F}
#----1km grid----
km_grid_17 <- st_read(here(import_path, "USNG", "USNG_UTM17.shp")) %>%
  st_as_sf(coords = c("Easting", "Northing"), crs = 27700) %>% 
  st_transform(4269) 

km_grid_18 <- st_read(here(import_path,"USNG", "USNG_UTM18.shp")) %>%
  st_as_sf(coords = c("Easting", "Northing"), crs = 27700) %>% 
  st_transform(4269) 

#combining UTM zones 17 and 18
km_grid <- rbind(km_grid_17, km_grid_18)

state_grid <- km_grid %>%
  st_as_sf(coords = c("Easting", "Northing"), crs = 27700) %>%
  st_transform(4269)

#--------state outline--------
state_outline <- tigris::states(state_name, cb = TRUE)

state_grid <- rbind(state_outline)

#combining 1km grids with county outlines
km_grid <-st_intersection(state_grid, state_outline)

#saving county grids
st_write(state_grid, here(export_path,"state_grid", "state_grid.shp"))

```

## Establishment Risk

```{r extracting risk layer, messages = F, warning = F}
#----establishment risk----
est_path <- here("ensemble.tif") 
establishment <- rast(est_path)

#extracting values from ensemble tif to subcounties
establishment_extract <- exact_extract(
  x = establishment, 
  y = km_grid,
  'mean')  

#turning output list in data frame and renaming column with risk values
establishment_extract <- data.frame(establishment_extract) %>%
  rename(establishment_value = establishment_extract)

#combining new df with risk values to old df with the geographic data
establishment_combined <- bind_cols(km_grid, establishment_extract) %>% 
  filter(establishment_extract != "NaN")

#writing file to computer
st_write(establishment_combined, file.path(export_path, "establishment_risk", "establishment_risk.shp"), driver = "ESRI Shapefile", append = TRUE)
```

## Getting POI data

```{r getting POI data}
POI_list <- c("hospitals", "policestations", "universities")

#created function that converts df to sf objects and matches same crs
df_to_sf <- function(dfs2) {
  st_as_sf(dfs2, coords = c("Longitude", "Latitude"), crs = 4269)
}

#for loop to retrieve and assign each df category
for(object in POI_list) {
  #PA_POI file path for each category
  file_path <- file.path(here("stateabb_POI", paste0(object, ".csv"))) %>%
    str_remove("/shapefiles")
  
  #loading in every stateabb_POI category
  df <- read.csv(file_path)
  
  #creating df for each stateabb_POI category
  assign(object, df)
}

#for loop to save points within each category
for(object in POI_list) {
  #getting new df category
  df <- get(object)
  
  #getting rid of any points that have NA lat/long
  df <- df %>%
    filter(!is.na(Longitude))
  
  #converting to sf object
  sf <- df_to_sf(df)
  
  #cropping points
  sf_state <- st_join(sf, state_outline, join = st_within, left = FALSE)
  
  #only proceed with the following lines of code if there are points within stateabb for that category
  if (length(st_geometry(sf_state)) > 0) {
   
    # since st_join saves columns from the state outline, this code creates lat/long columns from geometry 
    sf_state$Latitude <- sf::st_coordinates(sf_state)[, "Y"]
    sf_state$Longitude <- sf::st_coordinates(sf_state)[, "X"]
  
    #only selecting 4 necessary columns for php and dropping geometry
    sf_state <- sf_state %>%
      dplyr::select(Name, Address, Latitude, Longitude) %>%
      st_drop_geometry() 
  
    #saving objects as df so to inspect in Rstudio easily
    assign(paste0(object, "_state"), sf_state)
  
   #saving the new POI files
    write.csv(sf_state, here("state_POI", paste0(object, ".csv")), row.names = FALSE)
   }
}
```

## Hub Density

```{r hub density, messages = F, warning = F}
find_hub_density <- function(state = state_name){

#PART 1: Bringing together points
POI_categories <- c("hospitals", "policestations", "universities")

  POI <- NULL
  
  for (category in POI_categories) {
    POI_path <- file.path(here(paste0(state_name,"_POI"), paste0(category, ".csv"))) %>% 
      str_remove("/shapefiles")
    
    if(file.exists(POI_path)) {
      df <- read.csv(POI_path)
      
      POI <- rbind(POI, df)
    } else {
      print(paste("No file found for category:", category))
    }
  } 
    
    sf_POI <- st_as_sf(POI, coords = c("Longitude", "Latitude"), crs = 4269)
    
    name_POI <- paste0(state_name,"_POI")
    
    assign(name_POI, sf_POI)
    
#PART 2: MAKING HUB GRID
 hub_density_grid <- km_grid
 hub_density_grid$hub_count <- lengths(st_intersects(km_grid, sf_POI))

  density_name <- paste0(county_name,"density")

  assign(density_name, hub_density_grid)

}

# PART 3: SAVING HUB DENSITY FILE
st_write(hub_density, file.path(export_path, "hub_density", "hub_density.shp"), append = TRUE)
```

##Vineyard Acerage

```{r vineyard acreage layer, messages = F, echo = F}
#loading in vineyard acerage layer
grape <- rast("grape.tif")

#isolating grape layer
grape <- grape == 69

#getting km_grid and merging with grape layer
grape_extract <- exact_extract(
  x = grape,
  y = km_grid,
  'sum'
)

#turning output list in data frame and renaming column with risk values
grape_extract <- data.frame(grape_extract) %>%
  rename(grape_value = grape_extract)

# Apply the log transformation: log(x + min(x))
min_value <- min(grape_extract$grape_value[grape_extract$grape_value > 0], na.rm = TRUE)
grape_extract <- grape_extract %>%
  mutate(grape_value_log = log(grape_value + min_value))

#combining new df with grape values to old df with the geographic data
grape_extract_grid <- bind_cols(km_grid, grape_extract) %>% 
  filter(NAME != "County subdivisions not defined")

grape_extract_grid <- st_transform(grape_extract_grid, crs = 4326)

# visualizing grape_value
plot(grape_extract_grid["grape_value_log"])

#writing shapefile
st_write(grape_extract_grid, file.path(here(export_path, "grape_layer","grape_layer.shp")))

```

##Survey Data and Density

```{r}
#--------------------------------------obtaining pest data--------------------------------------------
process_slf_state <- function(pest_data, state_abbr) {
  pest_state <- pest_data %>%
    st_as_sf(coords = c("longitude", "latitude"), crs = 4269) %>%
    filter(state == state_abbr)
  
  pest_state <- st_intersection(pest_state, state_abbr)
  
  pest_2 <- pest_state %>% 
    st_drop_geometry() %>%   
    add_count(pointID, name = "survey_count") %>%
    mutate(pest_present = case_when(
              pest_present == "TRUE" ~ 1,
              pest_present == "FALSE" ~ 0 
    )) %>% 
    group_by(pointID) %>% 
    summarize(
      survey_count = n(), 
      max_pa = max(pest_present) 
    ) %>% 
    na.omit()
  
  pest_2 <- pest_state %>%
    left_join(pest_2, by = "pointID")  # Matches data by pointID
  
  property <- st_read(here("parcels.shp" )) %>%
  st_transform(4269) %>%
  st_make_valid()
  
  return(pest_2)
}

#----------------------identify polygons with points within a given distance------------------------------
get_polygons_with_points <- function(polygons, points, distance) {
  test <- st_is_within_distance(polygons, points, dist = distance)
  num_points_per_poly <- lengths(test)
  polygons_with_points <- polygons[num_points_per_poly > 0, ]
  polygons_with_points$survey_counts <- num_points_per_poly[num_points_per_poly > 0]
  indices <- test[num_points_per_poly > 0]
  
  polygons_with_points$pest_present <- sapply(indices, function(idx) max(points$max_pa[idx], na.rm = TRUE))
  polygons_with_points$max_pa <- pmax(polygons_with_points$pest_present, na.rm = TRUE)
  
  return(polygons_with_points)
}

#-----------------------perform spatial join and process data----------------------------------------------
process_grid_data <- function(km_grid, polygons_with_points, points, distance) {
  complete_grid <- km_grid
  join_grid_prop <- st_join(complete_grid, polygons_with_points, join = st_intersects)
  test_intersected <- st_is_within_distance(join_grid_prop, points, dist = distance)
  grid_points_per_poly <- lengths(test_intersected)
  
  join_grid_prop$survey_counts <- grid_points_per_poly
  join_grid_prop$survey_counts[is.na(join_grid_prop$survey_counts)] <- 0
  
  state_max <- function(idx) {
    if (length(idx) == 0 || all(is.na(idx))) {
      return(0)
    }
    max(points$max_pa[idx], na.rm = TRUE)
  }
  join_grid_prop$max_pa <- sapply(test_intersected, state_max)
  join_grid_prop$max_pa[is.infinite(join_grid_prop$max_pa)] <- 0
  join_grid_prop$max_pa[is.na(join_grid_prop$max_pa)] <- 0
  
  join_grid_prop <- join_grid_prop %>% distinct(USNG, .keep_all = TRUE)
  
  return(join_grid_prop)
}

#---------------------------saving as shapefile-------------------------------------------------------------
save_shapefile <- function(spatial_data, filepath) {
  st_write(spatial_data, filepath, append = FALSE)
}

#Usage:
polygons_with_points <- get_polygons_with_points(stateabbr_property, lycor_2, 10)
density_grid <- process_grid_data(km_grid, polygons_with_points, lycor_2, 10)
save_shapefile(density_grid, here("density_grid", "density_grid.shp"))

```

## Railways

```{r railways, messages = F, warning = F}
#loading in US railways shapefile
railway_path <- here("North_American_Rail_Network_Lines.shp") 

us_railways <- st_read(railway_path)

st_write(state_railways, file.path(write_railways_path), driver = "ESRI Shapefile", append = TRUE)

```

## Highways

```{r}
highway_path <- here("North_American_Roads.shp")

us_highway <- st_read(highway_path)

st_write(state_highways, file.path(write_highways_path), driver = "ESRI Shapefile", append = TRUE)

```

